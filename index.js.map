{
  "version": 3,
  "sources": ["../node_modules/.pnpm/css-string@1.0.1/node_modules/css-string/lib/css-string.js", "../node_modules/.pnpm/img-extract@1.0.0/node_modules/img-extract/lib/img-extract.js", "../src/fonts/seven.js", "../src/lib/store.js", "../src/view.js", "../src/lib/canvas.js", "../src/lib/canvas-recolor.js", "../src/lib/style-vshadow.js", "../src/disasm/charmap.js", "../src/disasm/charmap.js", "../src/lib/text-split.js", "../src/lib/rgb.js", "../node_modules/.pnpm/img-load@2.0.0/node_modules/img-load/lib/img-load.js", "../src/lib/disasm.js", "../src/lib/pixels.js", "../src/lib/pixels.js", "../src/disasm/palette.js", "../src/disasm/fonts.js", "../src/disasm/icons.js", "../src/disasm/tags.js", "../src/lib/canvas-replace.js", "../src/disasm/tags.js", "../src/fonts/index.js", "../src/fonts/index.js", "../src/sprites.js", "../src/render/box.js", "../src/lib/text-width.js", "../src/lib/style-shadow.js", "../src/render/text.js", "../src/render/tag.js", "../src/render/textbox.js", "../src/view.js", "../src/index.js"],
  "sourcesContent": ["module.exports = function stringify (style) {\n  let result = ''\n  let prefix = ''\n  for (const prop in style) {\n    const value = style[prop]\n    if (typeof value === 'object') {\n      result += prop + '{' + stringify(value) + '}'\n    } else {\n      result += prefix + prop + ':' + value\n      prefix = ';'\n    }\n  }\n  return result\n}\n", "module.exports = function extract(image, x, y, width, height) {\n  var canvas = document.createElement(\"canvas\")\n  var context = canvas.getContext(\"2d\")\n  canvas.width = width\n  canvas.height = height\n  context.drawImage(image, -x, -y)\n  return canvas\n}\n", "module.exports = {\n  id: 'seven',\n  cellwidth: 7,\n  cellheight: 9,\n  charwidth: 5,\n  charheight: 7,\n  charspace: 1,\n  wordspace: 3,\n  linespace: 5,\n  exceptions: {\n    1: { width: 3 },\n    I: { width: 3 },\n    f: { width: 4 },\n    g: { height: 9 },\n    i: { width: 1 },\n    j: { width: 2, height: 8 },\n    k: { width: 4 },\n    l: { width: 1, x: 0 },\n    m: { width: 7 },\n    p: { height: 9 },\n    q: { height: 9 },\n    r: { width: 4 },\n    t: { width: 4 },\n    w: { width: 7 },\n    y: { height: 9 },\n    ',': { width: 2, height: 9 },\n    '.': { width: 1 },\n    '!': { width: 1 },\n    '\\'': { width: 1 },\n    '(': { width: 3 },\n    ')': { width: 3 }\n  },\n  layout: [\n    '0123456789',\n    'ABCDEFGHIJ',\n    'KLMNOPQRST',\n    'UVWXYZ,.!?',\n    'abcdefghij',\n    'klmnopqrst',\n    'uvwxyz\\'()'\n  ]\n}\n", "export default function Store ({ state, actions }) {\n  const listeners = { '*': [] }\n  for (const cmdname in actions) {\n    listeners[cmdname] = []\n  }\n\n  const patches = /* JSON.parse(window.localStorage.patches || null) || */ []\n  if (patches.length) {\n    state = revert(state, patches)\n  } else {\n    state = { ...state }\n  }\n\n  const init = (fn) => {\n    fn(state, dispatch)\n  }\n\n  const listen = (cmdname, fn) => {\n    if (!listeners[cmdname]) {\n      throw new Error('Failed to listen for action ' + cmdname + ':' +\n        'Action has not been defined')\n    }\n    listeners[cmdname].push(fn)\n  }\n\n  const dispatch = (cmdname, ...cmdargs) => {\n    const action = actions[cmdname]\n    if (!action) {\n      throw new Error('Failed to dispatch command:' +\n        ' No corresponding action found for command ' + cmdname)\n    }\n    const patch = action(state, dispatch, cmdargs)\n    Object.assign(state, patch)\n    patches.push(patch)\n    // window.localStorage.patches = JSON.stringify(patches) // assumes state is serializable!\n\n    for (const fn of listeners['*'].concat(listeners[cmdname])) {\n      fn(state, dispatch)\n    }\n    return patch\n  }\n\n  return { init, listen, dispatch }\n}\n\n// revert(state, patch[]) -> state\n// reconstruct state given an initial state and list of patches\nfunction revert (state, patches) {\n  state = { ...state }\n  const keys = []\n  for (const key in state) {\n    keys.push(key)\n  }\n  for (let i = patches.length - 1; keys.length && i--;) {\n    const patch = patches[i]\n    for (const key in patch) {\n      const idx = keys.indexOf(key)\n      if (idx === -1) continue\n      keys.splice(idx, 1)\n      state[key] = patch[key]\n      if (!keys.length) break\n    }\n  }\n  return state\n}\n", "import cssify from 'css-string'\nimport { copy } from './lib/canvas'\nimport recolor from './lib/canvas-recolor'\nimport vshadow from './lib/style-vshadow'\nimport TextBox from './render/textbox'\nimport { icons, palette } from './sprites'\n\nconst $main = document.querySelector('main')\nconst $style = document.createElement('style')\ndocument.head.appendChild($style)\n\nlet textbox = null\nlet writing = true\nlet animating = false\nlet speakerid = null\nlet index = 0\nlet offset = 0\nlet arrow = null\nlet mask = null\n\nexport function render (state) {\n  if (animating) return false\n  if (writing) {\n    writing = textbox.write()\n  } else {\n    const ctx = textbox.canvas.getContext('2d')\n    const x = textbox.canvas.width - 16\n    const y = textbox.canvas.height - 16\n    const a = 1 // amplitude\n    const d = 45 // cycle duration\n    const t = state.time % d / d // time percentage\n    ctx.drawImage(mask, x, y + offset)\n    offset = Math.round(Math.sin(t * 2 * Math.PI) * a)\n    ctx.drawImage(arrow, x, y + offset)\n  }\n}\n\nexport function init (state, dispatch, listen) {\n  const viewport = state.viewport\n  const { width, height, scale } = viewport\n  $style.innerHTML = cssify({\n    main: {\n      width: width + 'px',\n      height: height + 'px',\n      transform: `scale(${scale})`\n    }\n  })\n\n  const scene = state.scene\n  const [id, content] = scene.script[scene.index]\n  const speaker = scene.actors[id]\n  const boxwidth = Math.min(200, viewport.width - 8)\n  textbox = TextBox(speaker.name, content, boxwidth)\n  textbox.canvas.className = 'textbox'\n  speakerid = id\n\n  // cache black arrow with a brown shadow\n  arrow = vshadow(recolor(copy(icons.arrow).canvas, palette.jet), palette.taupe)\n\n  // cache arrow mask for clearing previous draws\n  mask = recolor(copy(arrow).canvas, palette.beige)\n\n  setTimeout(_ => {\n    listen('update', render)\n    listen('advance', onadvance)\n\n    function update () {\n      dispatch('update')\n      window.requestAnimationFrame(update)\n    }\n\n    const $textbox = textbox.canvas\n    $main.appendChild($textbox)\n    animating = true\n    $textbox.classList.add('-enter')\n    $textbox.addEventListener('animationend', function onend () {\n      $textbox.removeEventListener('animationend', onend)\n      $textbox.classList.remove('-enter')\n      animating = false\n      update()\n    })\n\n    window.addEventListener('resize', _ => dispatch('resize'))\n    window.addEventListener('click', _ => dispatch('advance'))\n  }, 500)\n}\n\nfunction onadvance ({ scene }) {\n  if (scene.index === index) return\n  index = scene.index\n  const [id, content] = scene.script[scene.index]\n  if (speakerid !== id) {\n    speakerid = id\n\n    const $textbox = textbox.canvas\n    animating = true\n    $textbox.classList.add('-exit')\n    $textbox.addEventListener('animationend', function onend () {\n      $textbox.removeEventListener('animationend', onend)\n      $textbox.classList.remove('-exit')\n\n      const speaker = scene.actors[id]\n      textbox.rename(speaker.name, speaker.side)\n      textbox.load(content)\n\n      $textbox.classList.add('-enter')\n      $textbox.addEventListener('animationend', function onend () {\n        $textbox.removeEventListener('animationend', onend)\n        $textbox.classList.remove('-enter')\n        animating = false\n        writing = true\n      })\n    })\n  } else {\n    textbox.load(content)\n    writing = true\n  }\n}\n", "export function create (width, height) {\n  const canvas = document.createElement('canvas')\n  canvas.width = width\n  canvas.height = height\n  return canvas.getContext('2d')\n}\n\nexport function copy (canvas) {\n  const result = create(canvas.width, canvas.height)\n  result.drawImage(canvas, 0, 0)\n  return result\n}\n", "// recolor(canvas, color) -> canvas\n// > replaces all non-transparent pixels in `canvas` with `color`\nexport default function recolor (canvas, color) {\n  const context = canvas.getContext('2d')\n  const image = context.getImageData(0, 0, canvas.width, canvas.height)\n  if (!color[3]) {\n    color = [color[0], color[1], color[2], 255]\n  }\n  for (let i = 0; i < image.data.length; i += 4) {\n    if (image.data[i + 3] === 0) continue\n    for (let c = 0; c < 4; c++) {\n      image.data[i + c] = color[c]\n    }\n  }\n  context.putImageData(image, 0, 0)\n  return canvas\n}\n", "import { create as Canvas, copy } from './canvas'\nimport recolor from './canvas-recolor'\n\nexport default function drawVShadow (image, color) {\n  const result = Canvas(image.width + 1, image.height + 1)\n  const shadow = recolor(copy(image).canvas, color)\n  result.drawImage(shadow, 0, 1)\n  result.drawImage(image, 0, 0)\n  return result.canvas\n}\n", "import recolor from '../lib/canvas-recolor'\nimport extract from 'img-extract'\n\nexport { get, make }\n\nfunction get (font, color) {\n  if (font.cache[color]) return font.cache[color]\n  font.cache[color] = make(font.image, font.data, color)\n  return font.cache[color]\n}\n\nfunction make (image, font, color, stroke) {\n  if (!image) {\n    throw new Error('No image found for font ' +\n      font.id + '. Try rebuilding your spritesheet.')\n  }\n  const charmap = {}\n  const cols = image.width / font.cellwidth\n  const rows = image.height / font.cellheight\n  if (color) {\n    image = recolor(image, color)\n  }\n  for (let row = 0; row < rows; row++) {\n    for (let col = 0; col < cols; col++) {\n      const char = font.layout[row][col]\n      if (!char) continue\n      const size = {\n        width: font.charwidth,\n        height: font.charheight\n      }\n      const offsets = font.exceptions[char]\n      for (const axis in offsets) {\n        size[axis] = offsets[axis]\n      }\n      const x = col * font.cellwidth\n      const y = row * font.cellheight\n      const base = extract(image, x, y, size.width, size.height)\n      charmap[char] = base\n    }\n  }\n  return charmap\n}\n", "import recolor from '../lib/canvas-recolor'\nimport extract from 'img-extract'\n\nexport { get, make }\n\nfunction get (font, color) {\n  if (font.cache[color]) return font.cache[color]\n  font.cache[color] = make(font.image, font.data, color)\n  return font.cache[color]\n}\n\nfunction make (image, font, color, stroke) {\n  if (!image) {\n    throw new Error('No image found for font ' +\n      font.id + '. Try rebuilding your spritesheet.')\n  }\n  const charmap = {}\n  const cols = image.width / font.cellwidth\n  const rows = image.height / font.cellheight\n  if (color) {\n    image = recolor(image, color)\n  }\n  for (let row = 0; row < rows; row++) {\n    for (let col = 0; col < cols; col++) {\n      const char = font.layout[row][col]\n      if (!char) continue\n      const size = {\n        width: font.charwidth,\n        height: font.charheight\n      }\n      const offsets = font.exceptions[char]\n      for (const axis in offsets) {\n        size[axis] = offsets[axis]\n      }\n      const x = col * font.cellwidth\n      const y = row * font.cellheight\n      const base = extract(image, x, y, size.width, size.height)\n      charmap[char] = base\n    }\n  }\n  return charmap\n}\n", "export default function split (text, font, width) {\n  const lines = []\n  let space = 0\n  let split = 0\n  let x = 0\n  let i = 0\n  for (; i < text.length; i++) {\n    const char = text[i]\n    if (char === ' ') {\n      x += font.wordspace\n      space = i\n    } else {\n      const except = font.exceptions[char]\n      if (except && except.width) {\n        x += except.width + font.charspace\n      } else {\n        x += font.charwidth + font.charspace\n      }\n    }\n    if (x > width) {\n      x = 0\n      if (space) {\n        lines.push(text.slice(split, space))\n        split = space + 1\n        space = 0\n      } else if (i > split) {\n        lines.push(text.slice(split, i))\n        split = i\n      } else {\n        lines.push(text.slice(split, split + 1))\n        split = i + 1\n      }\n    }\n  }\n  const line = text.slice(split, i)\n  if (line) lines.push(line)\n  return lines\n}\n", "export default function rgb (r, g, b) {\n  return 'rgb(' + r + ', ' + g + ', ' + b + ')'\n}\n", "export default function loadImage(path) {\n  return new Promise(function (resolve, reject) {\n    var image = new Image()\n    image.src = path\n    image.onload = function () {\n      resolve(image)\n    }\n    image.onerror = function () {\n      reject(new Error(\"Failed to load image `\" + path + \"`\"))\n    }\n  })\n}\n", "import extract from 'img-extract'\n\nexport default function disasm(sheet, srcmap) {\n  const sprites = {}\n  for (const id in srcmap) {\n    if (Array.isArray(srcmap[id])) {\n      const [x, y, w, h] = srcmap[id]\n      sprites[id] = extract(sheet, x, y, w, h)\n    } else {\n      sprites[id] = disasm(sheet, srcmap[id])\n    }\n  }\n  return sprites\n}\n", "// fromImage(Image) -> ImageData\n// this function creates a garbage canvas\n// only use if you're sure you won't be needing it afterwards\nexport function fromImage (image) {\n  const canvas = document.createElement('canvas')\n  const context = image.getContext('2d')\n  canvas.width = image.width\n  canvas.height = image.height\n  context.drawImage(canvas, 0, 0)\n  return context.getImageData(0, 0, image.width, image.height)\n}\n\nexport function fromCanvas (canvas) {\n  return canvas\n    .getContext('2d')\n    .getImageData(0, 0, canvas.width, canvas.height)\n}\n\nexport function toCanvas (data) {\n  const canvas = document.createElement('canvas')\n  const context = canvas.getContext('2d')\n  canvas.width = data.width\n  canvas.height = data.height\n  context.putImageData(data, 0, 0)\n  return canvas\n}\n\nexport function get (image, x, y) {\n  const i = (y * image.width + x) * 4\n  const r = image.data[i]\n  const g = image.data[i + 1]\n  const b = image.data[i + 2]\n  const a = image.data[i + 3]\n  return [r, g, b, a]\n}\n\nexport function set (image, x, y, color) {\n  const i = (y * image.width + x) * 4\n  image.data[i + 0] = color[0]\n  image.data[i + 1] = color[1]\n  image.data[i + 2] = color[2]\n  image.data[i + 3] = color[3]\n}\n\nexport function replace (image, oldColor, newColor) {\n  if (oldColor.length === 3) oldColor = [...oldColor, 255]\n  if (newColor.length === 3) newColor = [...newColor, 255]\n  for (let i = 0; i < image.data.length; i += 4) {\n    let c = 0\n    while (image.data[i + c] === oldColor[c] && c < 4) {\n      c++\n    }\n\n    if (c < 4) {\n      continue\n    }\n\n    for (let c = 0; c < 4; c++) {\n      image.data[i + c] = newColor[c]\n    }\n  }\n  return image\n}\n\nexport function recolor (image, newColor) {\n  if (!newColor[3]) {\n    newColor = newColor.slice()\n    newColor[3] = 255\n  }\n  for (let i = 0; i < image.data.length; i += 4) {\n    if (image.data[i + 3] === 0) continue\n    for (let c = 0; c < 4; c++) {\n      image.data[i + c] = newColor[c]\n    }\n  }\n  return image\n}\n", "// fromImage(Image) -> ImageData\n// this function creates a garbage canvas\n// only use if you're sure you won't be needing it afterwards\nexport function fromImage (image) {\n  const canvas = document.createElement('canvas')\n  const context = image.getContext('2d')\n  canvas.width = image.width\n  canvas.height = image.height\n  context.drawImage(canvas, 0, 0)\n  return context.getImageData(0, 0, image.width, image.height)\n}\n\nexport function fromCanvas (canvas) {\n  return canvas\n    .getContext('2d')\n    .getImageData(0, 0, canvas.width, canvas.height)\n}\n\nexport function toCanvas (data) {\n  const canvas = document.createElement('canvas')\n  const context = canvas.getContext('2d')\n  canvas.width = data.width\n  canvas.height = data.height\n  context.putImageData(data, 0, 0)\n  return canvas\n}\n\nexport function get (image, x, y) {\n  const i = (y * image.width + x) * 4\n  const r = image.data[i]\n  const g = image.data[i + 1]\n  const b = image.data[i + 2]\n  const a = image.data[i + 3]\n  return [r, g, b, a]\n}\n\nexport function set (image, x, y, color) {\n  const i = (y * image.width + x) * 4\n  image.data[i + 0] = color[0]\n  image.data[i + 1] = color[1]\n  image.data[i + 2] = color[2]\n  image.data[i + 3] = color[3]\n}\n\nexport function replace (image, oldColor, newColor) {\n  if (oldColor.length === 3) oldColor = [...oldColor, 255]\n  if (newColor.length === 3) newColor = [...newColor, 255]\n  for (let i = 0; i < image.data.length; i += 4) {\n    let c = 0\n    while (image.data[i + c] === oldColor[c] && c < 4) {\n      c++\n    }\n\n    if (c < 4) {\n      continue\n    }\n\n    for (let c = 0; c < 4; c++) {\n      image.data[i + c] = newColor[c]\n    }\n  }\n  return image\n}\n\nexport function recolor (image, newColor) {\n  if (!newColor[3]) {\n    newColor = newColor.slice()\n    newColor[3] = 255\n  }\n  for (let i = 0; i < image.data.length; i += 4) {\n    if (image.data[i + 3] === 0) continue\n    for (let c = 0; c < 4; c++) {\n      image.data[i + c] = newColor[c]\n    }\n  }\n  return image\n}\n", "import { get, fromCanvas as pixelate } from '../lib/pixels'\n\nconst matrix = [\n  ['white', 'opal', 'pink', 'lime', 'opalhp', 'redhp'],\n  ['black', 'blue', 'red', 'green', null, 'orangehp'],\n  ['silver', 'navy', 'purple', 'teal', 'beige', 'yellowhp'],\n  ['gray', null, 'maroon', 'moss', 'taupe', 'greenhp'],\n  ['coal', null, 'yellow', 'gold', 'brass', 'bluehp'],\n  ['jet', null, 'cream', 'sage', 'brown', 'indigohp']\n]\n\nconst mappings = {\n  hp: {\n    opal: 'opal',\n    red: 'red',\n    orange: 'orangehp',\n    yellow: 'yellowhp',\n    green: 'greenhp',\n    blue: 'bluehp',\n    indigo: 'indigohp'\n  },\n  factions: {\n    player: {\n      light: 'opal',\n      normal: 'blue',\n      dark: 'navy'\n    },\n    enemy: {\n      light: 'pink',\n      normal: 'red',\n      dark: 'purple'\n    },\n    ally: {\n      light: 'lime',\n      normal: 'green',\n      dark: 'teal'\n    }\n  }\n}\n\nexport default function match (image) {\n  const palette = {}\n  const data = pixelate(image)\n  for (let y = 0; y < matrix.length; y++) {\n    for (let x = 0; x < matrix[y].length; x++) {\n      const colorname = matrix[y][x]\n      if (!colorname) continue\n      palette[colorname] = get(data, x, y)\n    }\n  }\n\n  assign(palette, mappings)\n  return palette\n\n  function assign (obj, mappings) {\n    for (const n in mappings) {\n      if (typeof mappings[n] === 'object') {\n        obj[n] = {}\n        assign(obj[n], mappings[n])\n      } else {\n        obj[n] = palette[mappings[n]]\n      }\n    }\n  }\n}\n", "import { make as makeCharmap } from './charmap'\n\nexport default function disasmFonts (images, fonts) {\n  const result = {}\n  for (const fontid in fonts) {\n    const font = fonts[fontid]\n    const image = images['font-' + font.id]\n    result[font.id] = {\n      image,\n      data: font,\n      cache: { '255,255,255,255': makeCharmap(image, font) }\n    }\n  }\n  return result\n}\n", "export default function disasmIcons (images) {\n  return { arrow: images.icons }\n}\n", "import extract from 'img-extract'\nimport replaceColors from '../lib/canvas-replace'\nimport { copy } from '../lib/canvas'\n\nexport default function disasmTags (image, palette) {\n  const tags = {}\n  const oldColors = [\n    [255, 255, 255, 255],\n    [204, 204, 204, 255],\n    [153, 153, 153, 255],\n    [102, 102, 102, 255],\n    [51, 51, 51, 255],\n    [0, 0, 0, 255]\n  ]\n  const yellows = [palette.yellow, palette.gold, palette.brass]\n  const colors = {\n    default: [palette.brass, palette.brown, palette.jet],\n    player: [palette.opal, palette.coal, palette.jet],\n    enemy: [palette.pink, palette.maroon, palette.jet],\n    ally: [palette.lime, palette.moss, palette.jet]\n  }\n\n  for (const scheme in colors) {\n    const subpal = colors[scheme]\n    const newColors = yellows.concat(subpal)\n    const canvas = copy(image).canvas\n    replaceColors(canvas, oldColors, newColors)\n    tags[scheme] = {\n      start: extract(canvas, 0, 0, 2, 12),\n      end: extract(canvas, 2, 0, 3, 12),\n      palette: subpal\n    }\n  }\n\n  return tags\n}\n", "// replaceColor(canvas, oldColors, newColors) -> canvas\n// > Replaces all instances of each color in oldColors\n// > with their respective indexed counterparts in\n// > newColors. The original canvas is mutated for\n// > optimal performance (subject to change).\nexport default function replaceColor (canvas, oldColors, newColors) {\n  const context = canvas.getContext('2d')\n  const image = context.getImageData(0, 0, canvas.width, canvas.height)\n  for (let i = 0; i < image.data.length; i += 4) {\n    let o = 0\n    for (; o < oldColors.length; o++) {\n      let c = 0\n      for (; c < 4; c++) {\n        if (image.data[i + c] !== oldColors[o][c]) {\n          break // next color\n        }\n      }\n      if (c === 4) {\n        break // match!\n      }\n    }\n    if (o < oldColors.length) {\n      // we found a match\n      // replace the current pixel\n      // with its corresponding color\n      for (let c = 0; c < 4; c++) {\n        image.data[i + c] = newColors[o][c]\n      }\n    }\n  }\n  context.putImageData(image, 0, 0)\n  return canvas\n}\n", "import extract from 'img-extract'\nimport replaceColors from '../lib/canvas-replace'\nimport { copy } from '../lib/canvas'\n\nexport default function disasmTags (image, palette) {\n  const tags = {}\n  const oldColors = [\n    [255, 255, 255, 255],\n    [204, 204, 204, 255],\n    [153, 153, 153, 255],\n    [102, 102, 102, 255],\n    [51, 51, 51, 255],\n    [0, 0, 0, 255]\n  ]\n  const yellows = [palette.yellow, palette.gold, palette.brass]\n  const colors = {\n    default: [palette.brass, palette.brown, palette.jet],\n    player: [palette.opal, palette.coal, palette.jet],\n    enemy: [palette.pink, palette.maroon, palette.jet],\n    ally: [palette.lime, palette.moss, palette.jet]\n  }\n\n  for (const scheme in colors) {\n    const subpal = colors[scheme]\n    const newColors = yellows.concat(subpal)\n    const canvas = copy(image).canvas\n    replaceColors(canvas, oldColors, newColors)\n    tags[scheme] = {\n      start: extract(canvas, 0, 0, 2, 12),\n      end: extract(canvas, 2, 0, 3, 12),\n      palette: subpal\n    }\n  }\n\n  return tags\n}\n", "import seven from './seven'\n\nexport { seven }\n", "import seven from './seven'\n\nexport { seven }\n", "import srcmap from '../dist/tmp/sprites.json'\nimport loadImage from 'img-load'\nimport disasm from './lib/disasm'\nimport disasmPalette from './disasm/palette'\nimport disasmFonts from './disasm/fonts'\nimport disasmIcons from './disasm/icons'\nimport disasmTags from './disasm/tags'\nimport * as fontdata from './fonts'\n\nexport let palette = null\nexport let fonts = null\nexport let icons = null\nexport let tags = null\n\nexport async function load (path) {\n  const sheet = await loadImage(path)\n  const images = disasm(sheet, srcmap)\n  palette = disasmPalette(images.palette)\n  fonts = disasmFonts(images, fontdata)\n  icons = disasmIcons(images)\n  tags = disasmTags(images.tags, palette)\n}\n", "import { palette } from '../sprites'\nimport { create as Canvas } from '../lib/canvas'\nimport rgb from '../lib/rgb'\n\nexport default function Box (width, height) {\n  const box = Canvas(width + 2, height + 2)\n  box.fillStyle = rgb(...palette.brown)\n  box.fillRect(0, 1, width + 2, height)\n  box.fillRect(1, 0, width, height + 2)\n  box.fillStyle = rgb(...palette.taupe)\n  box.fillRect(0, 1, width + 1, height - 1)\n  box.fillRect(1, 0, width - 1, height + 1)\n  box.fillStyle = rgb(...palette.beige)\n  box.fillRect(0, 1, width, height - 2)\n  box.fillRect(1, 0, width - 2, height)\n  box.fillStyle = rgb(...palette.taupe)\n  box.fillRect(2, 1, width - 4, height - 2)\n  box.fillRect(1, 2, width - 2, height - 4)\n  box.fillStyle = rgb(...palette.beige)\n  box.fillRect(2, 2, width - 4, height - 4)\n  return box.canvas\n}\n", "export default function findTextWidth (content, font) {\n  let width = 0\n  for (const char of content) {\n    if (char === ' ') {\n      width += font.data.wordspace\n      continue\n    }\n    const cache = font.cache['255,255,255,255']\n    let image = cache[char]\n    if (!image) image = cache[char.toUpperCase()]\n    if (!image) continue\n    width += image.width + font.data.charspace\n  }\n  if (width) {\n    width -= font.data.charspace\n  }\n  return width\n}\n", "import { create as Canvas, copy } from '../lib/canvas'\nimport recolor from '../lib/canvas-recolor'\n\nexport default function drawShadow (image, color) {\n  const result = Canvas(image.width + 1, image.height + 1)\n  const shadow = recolor(copy(image).canvas, color)\n  result.drawImage(shadow, 0, 1)\n  result.drawImage(shadow, 1, 0)\n  result.drawImage(shadow, 1, 1)\n  result.drawImage(image, 0, 0)\n  return result.canvas\n}\n", "import { fonts, palette } from '../sprites'\nimport { make as makeCharmap } from '../disasm/charmap'\nimport { create as Canvas } from '../lib/canvas'\nimport findTextWidth from '../lib/text-width'\nimport drawShadow from '../lib/style-shadow'\n\nexport default function Text (content, style, width) {\n  style = Object.assign({\n    font: fonts.seven,\n    color: palette.white,\n    shadow: null\n  }, style)\n  const font = style.font\n  if (!font) {\n    throw new Error('Attempting to render an unregistered font.' +\n      ' Is your font exported by fonts/index.js?')\n  }\n  let charmap = font.cache[style.color]\n  if (!charmap) {\n    charmap = makeCharmap(font.image, font.data, style.color)\n    font.cache[style.color] = charmap\n  }\n  content = content.toString()\n  if (!width) {\n    width = findTextWidth(content, font, style.stroke)\n  }\n  let height = font.data.cellheight\n  if (style.stroke) {\n    height += 2\n  }\n  const text = Canvas(width, height)\n  let x = 0\n  let kerning = font.data.charspace\n  if (style.stroke) {\n    kerning -= 2\n  }\n  for (const char of content) {\n    if (char === ' ') {\n      x += font.data.wordspace\n      continue\n    }\n    let image = charmap[char]\n    if (!image) image = charmap[char.toUpperCase()]\n    if (!image) continue\n    text.drawImage(image, x, 0)\n    x += image.width + kerning\n  }\n  if (style.shadow) {\n    return drawShadow(text.canvas, style.shadow)\n  } else {\n    return text.canvas\n  }\n}\n", "import { create as Canvas } from '../lib/canvas'\nimport rgb from '../lib/rgb'\nimport Text from './text'\nimport { tags, palette } from '../sprites'\n\nexport default function renderNameTag (name, faction) {\n  const pady = 2\n  const text = Text(name, { shadow: palette.jet })\n  const width = 52\n  const height = pady + text.height - 2 + pady\n  const tag = renderTag(width, height, faction)\n    .getContext('2d')\n  const x = Math.ceil(width / 2 - (text.width - 1) / 2)\n  tag.drawImage(text, x, pady)\n  return tag.canvas\n}\n\nfunction renderTag (width, height, faction) {\n  if (!faction) faction = 'default'\n  const palette = tags[faction].palette\n  const tag = Canvas(width + 1, height)\n  tag.fillStyle = rgb(...palette[0])\n  tag.fillRect(2, 0, width - 3, 1)\n  tag.fillStyle = rgb(...palette[1])\n  tag.fillRect(2, 1, width - 3, height - 2)\n  tag.fillStyle = rgb(...palette[2])\n  tag.fillRect(2, height - 1, width - 3, 1)\n  tag.drawImage(tags[faction].start, 0, 0)\n  tag.drawImage(tags[faction].end, width - 2, 0)\n  return tag.canvas\n}\n", "import { get as getCharmap } from '../disasm/charmap'\nimport { create as Canvas } from '../lib/canvas'\nimport vshadow from '../lib/style-vshadow'\nimport split from '../lib/text-split'\nimport rgb from '../lib/rgb'\nimport { fonts, palette } from '../sprites'\nimport Box from './box'\nimport Tag from './tag'\n\nexport default function TextBox (name, content, width) {\n  const padx = 9\n  const pady = 8\n  const tagx = 6\n  const tagy = 8\n  const font = fonts.seven\n\n  const innerwidth = width - padx * 2\n  const height = (font.data.cellheight + font.data.linespace) * 2 + pady * 2\n  const box = Box(width - 2, height - 2)\n  let tag = null\n\n  const textbox = Canvas(width, height + tagy)\n  rename(name)\n\n  const charmap = getCharmap(font, palette.jet)\n  const shadowmap = getCharmap(font, palette.taupe)\n  let i, x, y, col, row, lines\n  load(content)\n\n  return { canvas: textbox.canvas, write, load, rename }\n\n  function write () {\n    const char = content[i++]\n    if (!char) return false\n    if (char === ' ') {\n      x += font.data.wordspace\n    } else {\n      const image = charmap[char] || charmap[char.toUpperCase()]\n      if (!image) {\n        console.warn('No char found for \"' + char + '\", skipping...')\n      } else {\n        const shadow = shadowmap[char] || shadowmap[char.toUpperCase()]\n        textbox.drawImage(shadow, x + 1, y + 1)\n        textbox.drawImage(shadow, x, y + 1)\n        textbox.drawImage(shadow, x + 1, y)\n        textbox.drawImage(image, x, y)\n        x += image.width + font.data.charspace\n      }\n    }\n    if (++col > lines[row].length) {\n      x = padx\n      y += font.data.cellheight + font.data.linespace\n      col = 0\n      row++\n    }\n    return true\n  }\n\n  function load (text) {\n    clear()\n    i = 0\n    x = padx\n    y = pady + tagy + 2\n    col = 0\n    row = 0\n    content = text\n    lines = split(content, font.data, innerwidth)\n  }\n\n  function clear () {\n    textbox.fillStyle = rgb(...palette.beige)\n    textbox.fillRect(padx, pady + tagy + 1, width - padx * 2, height - pady * 2 + 1)\n  }\n\n  function rename (name, side = 'left') {\n    tag = vshadow(Tag(name), palette.taupe)\n    let x = tagx\n    if (side === 'right') {\n      x = textbox.canvas.width - tag.width - tagx\n    }\n    textbox.clearRect(0, 0, textbox.canvas.width, textbox.canvas.height)\n    textbox.drawImage(box, 0, tagy)\n    textbox.drawImage(tag, x, 0)\n  }\n}\n", "import cssify from 'css-string'\nimport { copy } from './lib/canvas'\nimport recolor from './lib/canvas-recolor'\nimport vshadow from './lib/style-vshadow'\nimport TextBox from './render/textbox'\nimport { icons, palette } from './sprites'\n\nconst $main = document.querySelector('main')\nconst $style = document.createElement('style')\ndocument.head.appendChild($style)\n\nlet textbox = null\nlet writing = true\nlet animating = false\nlet speakerid = null\nlet index = 0\nlet offset = 0\nlet arrow = null\nlet mask = null\n\nexport function render (state) {\n  if (animating) return false\n  if (writing) {\n    writing = textbox.write()\n  } else {\n    const ctx = textbox.canvas.getContext('2d')\n    const x = textbox.canvas.width - 16\n    const y = textbox.canvas.height - 16\n    const a = 1 // amplitude\n    const d = 45 // cycle duration\n    const t = state.time % d / d // time percentage\n    ctx.drawImage(mask, x, y + offset)\n    offset = Math.round(Math.sin(t * 2 * Math.PI) * a)\n    ctx.drawImage(arrow, x, y + offset)\n  }\n}\n\nexport function init (state, dispatch, listen) {\n  const viewport = state.viewport\n  const { width, height, scale } = viewport\n  $style.innerHTML = cssify({\n    main: {\n      width: width + 'px',\n      height: height + 'px',\n      transform: `scale(${scale})`\n    }\n  })\n\n  const scene = state.scene\n  const [id, content] = scene.script[scene.index]\n  const speaker = scene.actors[id]\n  const boxwidth = Math.min(200, viewport.width - 8)\n  textbox = TextBox(speaker.name, content, boxwidth)\n  textbox.canvas.className = 'textbox'\n  speakerid = id\n\n  // cache black arrow with a brown shadow\n  arrow = vshadow(recolor(copy(icons.arrow).canvas, palette.jet), palette.taupe)\n\n  // cache arrow mask for clearing previous draws\n  mask = recolor(copy(arrow).canvas, palette.beige)\n\n  setTimeout(_ => {\n    listen('update', render)\n    listen('advance', onadvance)\n\n    function update () {\n      dispatch('update')\n      window.requestAnimationFrame(update)\n    }\n\n    const $textbox = textbox.canvas\n    $main.appendChild($textbox)\n    animating = true\n    $textbox.classList.add('-enter')\n    $textbox.addEventListener('animationend', function onend () {\n      $textbox.removeEventListener('animationend', onend)\n      $textbox.classList.remove('-enter')\n      animating = false\n      update()\n    })\n\n    window.addEventListener('resize', _ => dispatch('resize'))\n    window.addEventListener('click', _ => dispatch('advance'))\n  }, 500)\n}\n\nfunction onadvance ({ scene }) {\n  if (scene.index === index) return\n  index = scene.index\n  const [id, content] = scene.script[scene.index]\n  if (speakerid !== id) {\n    speakerid = id\n\n    const $textbox = textbox.canvas\n    animating = true\n    $textbox.classList.add('-exit')\n    $textbox.addEventListener('animationend', function onend () {\n      $textbox.removeEventListener('animationend', onend)\n      $textbox.classList.remove('-exit')\n\n      const speaker = scene.actors[id]\n      textbox.rename(speaker.name, speaker.side)\n      textbox.load(content)\n\n      $textbox.classList.add('-enter')\n      $textbox.addEventListener('animationend', function onend () {\n        $textbox.removeEventListener('animationend', onend)\n        $textbox.classList.remove('-enter')\n        animating = false\n        writing = true\n      })\n    })\n  } else {\n    textbox.load(content)\n    writing = true\n  }\n}\n", "import Store from './lib/store'\nimport { init as initview } from './view'\nimport { load } from './sprites'\n\nconst units = [\n  { name: 'Chorizo', cell: [2, 7], faction: 'player' },\n  { name: 'Orc', cell: [7, 2], faction: 'enemy' }\n]\n\nconst { init, listen } = Store({\n  state: {\n    time: 0,\n    screen: 'game',\n    scene: {\n      index: 0,\n      writing: true,\n      done: false,\n      actors: [\n        { name: 'Dodo', side: 'left' },\n        { name: '???', side: 'right' },\n        { name: '???', side: 'left' }\n      ],\n      script: [\n        [0, 'Hi! Let\\'s draw some text.'],\n        [0, 'Here\\'s some long text that displays on two lines.'],\n        [1, 'When someone else talks, the text box reanimates.'],\n        [1, 'An actor\\'s name can be drawn on either side.'],\n        [2, 'Each actor also has its own ID.'],\n        [2, 'This way, different actors can have the same name.']\n      ]\n    },\n    game: {\n      select: null,\n      width: 9,\n      height: 9,\n      units: units,\n      pending: units.filter(unit => unit.faction === 'player'),\n      phase: 'player'\n    },\n    viewport: {\n      native: {\n        width: 160,\n        height: 160\n      },\n      width: window.innerWidth,\n      height: window.innerHeight,\n      scale: 2\n    }\n  },\n  actions: {\n    update: (state) =>\n      ({ time: state.time + 1 }),\n\n    switchscr: (state, _, [newscr]) =>\n      ({ screen: newscr }),\n\n    resize: ({ viewport }) => {\n      const minhscale = Math.floor(window.innerWidth / viewport.native.width)\n      const minvscale = Math.floor(window.innerHeight / viewport.native.height)\n      const hscale = Math.max(1, minhscale)\n      const vscale = Math.max(1, minvscale)\n      const scale = Math.min(hscale, vscale)\n      const width = Math.ceil(window.innerWidth / scale)\n      const height = Math.ceil(window.innerHeight / scale)\n      return { viewport: { ...viewport, width, height, scale } }\n    },\n\n    // advance(state)\n    // skips the writing phase if writing\n    // otherwise, tries to go to the next page\n    // if no next page exists, does nothing\n    advance: ({ scene }) => {\n      if (!scene.script[scene.index + 1]) return { scene }\n      // if (scene.writing) return { scene: { ...scene, writing: false } }\n      return { scene: { ...scene, writing: true, index: scene.index + 1 } }\n    }\n  }\n})\n\ninit(async (state, dispatch) => {\n  await load('./sprites.png')\n  dispatch('resize')\n  initview(state, dispatch, listen)\n})\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,MAAA;AAAA,WAAO,UAAU;AACf,mBAAa;AACb,mBAAa;AACb,yBAAmB;AACjB,sBAAc,MAAM;AACpB,YAAI,OAAO,UAAU;AACnB,oBAAU,OAAO,MAAM,UAAU,SAAS;AAAA;AAE1C,oBAAU,SAAS,OAAO,MAAM;AAChC,mBAAS;AAAA;AAAA;AAGb,aAAO;AAAA;AAAA;;;ACZT,MAAA;AAAA,WAAO,UAAU;AACf,oBAAa,SAAS,cAAc;AACpC,oBAAc,QAAO,WAAW;AAChC,cAAO,QAAQ;AACf,cAAO,SAAS;AAChB,cAAQ,UAAU,OAAO,CAAC,GAAG,CAAC;AAC9B,aAAO;AAAA;AAAA;;;ACNT,MAAA;AAAA,WAAO,UAAU;AAAA,MACf,IAAI;AAAA,MACJ,WAAW;AAAA,MACX,YAAY;AAAA,MACZ,WAAW;AAAA,MACX,YAAY;AAAA,MACZ,WAAW;AAAA,MACX,WAAW;AAAA,MACX,WAAW;AAAA,MACX,YAAY;AAAA,QACV,GAAG,CAAE,OAAO;AAAA,QACZ,GAAG,CAAE,OAAO;AAAA,QACZ,GAAG,CAAE,OAAO;AAAA,QACZ,GAAG,CAAE,QAAQ;AAAA,QACb,GAAG,CAAE,OAAO;AAAA,QACZ,GAAG,CAAE,OAAO,GAAG,QAAQ;AAAA,QACvB,GAAG,CAAE,OAAO;AAAA,QACZ,GAAG,CAAE,OAAO,GAAG,GAAG;AAAA,QAClB,GAAG,CAAE,OAAO;AAAA,QACZ,GAAG,CAAE,QAAQ;AAAA,QACb,GAAG,CAAE,QAAQ;AAAA,QACb,GAAG,CAAE,OAAO;AAAA,QACZ,GAAG,CAAE,OAAO;AAAA,QACZ,GAAG,CAAE,OAAO;AAAA,QACZ,GAAG,CAAE,QAAQ;AAAA,QACb,KAAK,CAAE,OAAO,GAAG,QAAQ;AAAA,QACzB,KAAK,CAAE,OAAO;AAAA,QACd,KAAK,CAAE,OAAO;AAAA,QACd,KAAM,CAAE,OAAO;AAAA,QACf,KAAK,CAAE,OAAO;AAAA,QACd,KAAK,CAAE,OAAO;AAAA;AAAA,MAEhB,QAAQ;AAAA,QACN;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA;AAAA;AAAA;;;ACvCW,iBAAgB,CAAE,OAAO;AACtC,sBAAkB,CAAE,KAAK;AACzB,0BAAsB;AACpB,gBAAU,WAAW;AAAA;AAGvB,oBAAyE;AACzE,QAAI,QAAQ;AACV,cAAQ,OAAO,OAAO;AAAA;AAEtB,cAAQ,IAAK;AAAA;AAGf,kBAAa;AACX,SAAG,OAAO;AAAA;AAGZ,oBAAe;AACb,UAAI,CAAC,UAAU;AACb,cAAM,IAAI,MAAM,iCAAiC,UAAU;AAAA;AAG7D,gBAAU,SAAS,KAAK;AAAA;AAG1B,qBAAiB;AACf,qBAAe,QAAQ;AACvB,UAAI,CAAC;AACH,cAAM,IAAI,MAAM,2EACkC;AAAA;AAEpD,oBAAc,OAAO,OAAO,UAAU;AACtC,aAAO,OAAO,OAAO;AACrB,cAAQ,KAAK;AAGb,uBAAiB,UAAU,KAAK,OAAO,UAAU;AAC/C,WAAG,OAAO;AAAA;AAEZ,aAAO;AAAA;AAGT,WAAO,CAAE,aAAM,iBAAQ;AAAA;AAKzB;AACE,YAAQ,IAAK;AACb,iBAAa;AACb,sBAAkB;AAChB,WAAK,KAAK;AAAA;AAEZ,iBAAa,QAAQ,SAAS,GAAG,KAAK,UAAU;AAC9C,oBAAc,QAAQ;AACtB,wBAAkB;AAChB,oBAAY,KAAK,QAAQ;AACzB,YAAI,QAAQ;AAAI;AAChB,aAAK,OAAO,KAAK;AACjB,cAAM,OAAO,MAAM;AACnB,YAAI,CAAC,KAAK;AAAQ;AAAA;AAAA;AAGtB,WAAO;AAAA;;;AC/DT,MAAA,aAAmB;;;ACAZ,kBAAiB;AACtB,oBAAe,SAAS,cAAc;AACtC,YAAO,QAAQ;AACf,YAAO,SAAS;AAChB,WAAO,QAAO,WAAW;AAAA;AAGpB;AACL,mBAAe,OAAO,QAAO,OAAO,QAAO;AAC3C,WAAO,UAAU,SAAQ,GAAG;AAC5B,WAAO;AAAA;;;ACRM,mBAAkB;AAC/B,oBAAgB,QAAO,WAAW;AAClC,kBAAc,QAAQ,aAAa,GAAG,GAAG,QAAO,OAAO,QAAO;AAC9D,QAAI,CAAC,MAAM;AACT,cAAQ,CAAC,MAAM,IAAI,MAAM,IAAI,MAAM,IAAI;AAAA;AAEzC,iBAAa,GAAG,IAAI,MAAM,KAAK,QAAQ,KAAK;AAC1C,UAAI,MAAM,KAAK,IAAI,OAAO;AAAG;AAC7B,mBAAa,GAAG,IAAI,GAAG;AACrB,cAAM,KAAK,IAAI,KAAK,MAAM;AAAA;AAAA;AAG9B,YAAQ,aAAa,OAAO,GAAG;AAC/B,WAAO;AAAA;;;ACZM,uBAAsB;AACnC,mBAAe,OAAO,MAAM,QAAQ,GAAG,MAAM,SAAS;AACtD,mBAAe,QAAQ,KAAK,OAAO,QAAQ;AAC3C,WAAO,UAAU,QAAQ,GAAG;AAC5B,WAAO,UAAU,OAAO,GAAG;AAC3B,WAAO,OAAO;AAAA;;;ACPhB,MAAA,cAAoB;ACIpB,eAAc;AACZ,QAAI,KAAK,MAAM;AAAQ,aAAO,KAAK,MAAM;AACzC,SAAK,MAAM,SAAS,KAAK,KAAK,OAAO,KAAK,MAAM;AAChD,WAAO,KAAK,MAAM;AAAA;AAGpB;AACE,QAAI,CAAC;AACH,YAAM,IAAI,MAAM,6BACd,KAAK,KAAK;AAAA;AAEd,qBAAgB;AAChB,iBAAa,MAAM,QAAQ,KAAK;AAChC,iBAAa,MAAM,SAAS,KAAK;AACjC,QAAI;AACF,cAAQ,QAAQ,OAAO;AAAA;AAEzB,mBAAe,GAAG,MAAM,MAAM;AAC5B,qBAAe,GAAG,MAAM,MAAM;AAC5B,qBAAa,KAAK,OAAO,KAAK;AAC9B,YAAI,CAAC;AAAM;AACX,qBAAa;AAAA,UACX,OAAO,KAAK;AAAA,UACZ,QAAQ,KAAK;AAAA;AAEf,wBAAgB,KAAK,WAAW;AAChC,2BAAmB;AACjB,eAAK,QAAQ,QAAQ;AAAA;AAEvB,kBAAU,MAAM,KAAK;AACrB,kBAAU,MAAM,KAAK;AACrB,qBAAa,oBAAQ,OAAO,GAAG,GAAG,KAAK,OAAO,KAAK;AACnD,iBAAQ,QAAQ;AAAA;AAAA;AAGpB,WAAO;AAAA;;;ACxCM,iBAAgB;AAC7B,kBAAc;AACd,gBAAY;AACZ,iBAAY;AACZ,YAAQ;AACR,YAAQ;AACR,WAAO,IAAI,MAAK,QAAQ;AACtB,mBAAa,MAAK;AAClB,UAAI,SAAS;AACX,aAAK,KAAK;AACV,gBAAQ;AAAA;AAER,uBAAe,KAAK,WAAW;AAC/B,YAAI,UAAU,OAAO;AACnB,eAAK,OAAO,QAAQ,KAAK;AAAA;AAEzB,eAAK,KAAK,YAAY,KAAK;AAAA;AAAA;AAG/B,UAAI,IAAI;AACN,YAAI;AACJ,YAAI;AACF,gBAAM,KAAK,MAAK,MAAM,QAAO;AAC7B,mBAAQ,QAAQ;AAChB,kBAAQ;AAAA,mBACC,IAAI;AACb,gBAAM,KAAK,MAAK,MAAM,QAAO;AAC7B,mBAAQ;AAAA;AAER,gBAAM,KAAK,MAAK,MAAM,QAAO,SAAQ;AACrC,mBAAQ,IAAI;AAAA;AAAA;AAAA;AAIlB,iBAAa,MAAK,MAAM,QAAO;AAC/B,QAAI;AAAM,YAAM,KAAK;AACrB,WAAO;AAAA;;;ACpCM,eAAc;AAC3B,WAAO,SAAS,IAAI,OAAO,IAAI,OAAO,IAAI;AAAA;;;;;;;;;;;ACD7B,qBAAmB;AAChC,WAAO,IAAI,QAAQ;AACjB,kBAAY,IAAI;AAChB,YAAM,MAAM;AACZ,YAAM,SAAS;AACb,gBAAQ;AAAA;AAEV,YAAM,UAAU;AACd,eAAO,IAAI,MAAM,2BAA2B,OAAO;AAAA;AAAA;AAAA;;;ACRzD,MAAA,eAAoB;AAEL;AACb,qBAAgB;AAChB,qBAAiB;AACf,UAAI,MAAM,QAAQ,OAAO;AACvB,6BAAqB,OAAO;AAC5B,iBAAQ,MAAM,qBAAQ,OAAO,GAAG,GAAG,GAAG;AAAA;AAEtC,iBAAQ,MAAM,OAAO,OAAO,OAAO;AAAA;AAAA;AAGvC,WAAO;AAAA;;;ACAF,sBAAqB;AAC1B,WAAO,QACJ,WAAW,MACX,aAAa,GAAG,GAAG,QAAO,OAAO,QAAO;AAAA;ACYtC,gBAAc;AACnB,cAAW,KAAI,MAAM,QAAQ,KAAK;AAClC,cAAU,MAAM,KAAK;AACrB,cAAU,MAAM,KAAK,IAAI;AACzB,cAAU,MAAM,KAAK,IAAI;AACzB,cAAU,MAAM,KAAK,IAAI;AACzB,WAAO,CAAC,GAAG,GAAG,GAAG;AAAA;;;AC/BnB,MAAM,SAAS;AAAA,IACb,CAAC,SAAS,QAAQ,QAAQ,QAAQ,UAAU;AAAA,IAC5C,CAAC,SAAS,QAAQ,OAAO,SAAS,MAAM;AAAA,IACxC,CAAC,UAAU,QAAQ,UAAU,QAAQ,SAAS;AAAA,IAC9C,CAAC,QAAQ,MAAM,UAAU,QAAQ,SAAS;AAAA,IAC1C,CAAC,QAAQ,MAAM,UAAU,QAAQ,SAAS;AAAA,IAC1C,CAAC,OAAO,MAAM,SAAS,QAAQ,SAAS;AAAA;AAG1C,iBAAiB;AAAA,IACf,IAAI;AAAA,MACF,MAAM;AAAA,MACN,KAAK;AAAA,MACL,QAAQ;AAAA,MACR,QAAQ;AAAA,MACR,OAAO;AAAA,MACP,MAAM;AAAA,MACN,QAAQ;AAAA;AAAA,IAEV,UAAU;AAAA,MACR,QAAQ;AAAA,QACN,OAAO;AAAA,QACP,QAAQ;AAAA,QACR,MAAM;AAAA;AAAA,MAER,OAAO;AAAA,QACL,OAAO;AAAA,QACP,QAAQ;AAAA,QACR,MAAM;AAAA;AAAA,MAER,MAAM;AAAA,QACJ,OAAO;AAAA,QACP,QAAQ;AAAA,QACR,MAAM;AAAA;AAAA;AAAA;AAKG;AACb,qBAAgB;AAChB,iBAAa,WAAS;AACtB,iBAAa,GAAG,IAAI,OAAO,QAAQ;AACjC,mBAAa,GAAG,IAAI,OAAO,GAAG,QAAQ;AACpC,0BAAkB,OAAO,GAAG;AAC5B,YAAI,CAAC;AAAW;AAChB,iBAAQ,aAAa,KAAI,MAAM,GAAG;AAAA;AAAA;AAItC,WAAO,UAAS;AAChB,WAAO;AAEP;AACE,sBAAgB;AACd,YAAI,OAAO,UAAS,OAAO;AACzB,cAAI,KAAK;AACT,iBAAO,IAAI,IAAI,UAAS;AAAA;AAExB,cAAI,KAAK,SAAQ,UAAS;AAAA;AAAA;AAAA;AAAA;;;AC1DnB,uBAAsB;AACnC,mBAAe;AACf,yBAAqB;AACnB,mBAAa,OAAM;AACnB,oBAAc,OAAO,UAAU,KAAK;AACpC,aAAO,KAAK,MAAM;AAAA,QAChB;AAAA,QACA,MAAM;AAAA,QACN,OAAO,CAAE,mBAAmB,KAAY,OAAO;AAAA;AAAA;AAGnD,WAAO;AAAA;;;ACbM,uBAAsB;AACnC,WAAO,CAAE,OAAO,OAAO;AAAA;;;ACDzB,MAAA,eAAoB;;;ACKL,wBAAuB;AACpC,oBAAgB,QAAO,WAAW;AAClC,kBAAc,QAAQ,aAAa,GAAG,GAAG,QAAO,OAAO,QAAO;AAC9D,iBAAa,GAAG,IAAI,MAAM,KAAK,QAAQ,KAAK;AAC1C,cAAQ;AACR,aAAO,IAAI,UAAU,QAAQ;AAC3B,gBAAQ;AACR,eAAO,IAAI,GAAG;AACZ,cAAI,MAAM,KAAK,IAAI,OAAO,UAAU,GAAG;AACrC;AAAA;AAAA;AAGJ,YAAI,MAAM;AACR;AAAA;AAAA;AAGJ,UAAI,IAAI,UAAU;AAIhB,qBAAa,GAAG,IAAI,GAAG;AACrB,gBAAM,KAAK,IAAI,KAAK,UAAU,GAAG;AAAA;AAAA;AAAA;AAIvC,YAAQ,aAAa,OAAO,GAAG;AAC/B,WAAO;AAAA;;;AC3BM,sBAAqB;AAClC,kBAAa;AACb,sBAAkB;AAAA,MAChB,CAAC,KAAK,KAAK,KAAK;AAAA,MAChB,CAAC,KAAK,KAAK,KAAK;AAAA,MAChB,CAAC,KAAK,KAAK,KAAK;AAAA,MAChB,CAAC,KAAK,KAAK,KAAK;AAAA,MAChB,CAAC,IAAI,IAAI,IAAI;AAAA,MACb,CAAC,GAAG,GAAG,GAAG;AAAA;AAEZ,oBAAgB,CAAC,SAAQ,QAAQ,SAAQ,MAAM,SAAQ;AACvD,mBAAe;AAAA,MACb,SAAS,CAAC,SAAQ,OAAO,SAAQ,OAAO,SAAQ;AAAA,MAChD,QAAQ,CAAC,SAAQ,MAAM,SAAQ,MAAM,SAAQ;AAAA,MAC7C,OAAO,CAAC,SAAQ,MAAM,SAAQ,QAAQ,SAAQ;AAAA,MAC9C,MAAM,CAAC,SAAQ,MAAM,SAAQ,MAAM,SAAQ;AAAA;AAG7C,yBAAqB;AACnB,qBAAe,OAAO;AACtB,wBAAkB,QAAQ,OAAO;AACjC,sBAAe,KAAK,OAAO;AAC3B,mBAAc,SAAQ,WAAW;AACjC,YAAK,UAAU;AAAA,QACb,OAAO,qBAAQ,SAAQ,GAAG,GAAG,GAAG;AAAA,QAChC,KAAK,qBAAQ,SAAQ,GAAG,GAAG,GAAG;AAAA,QAC9B,SAAS;AAAA;AAAA;AAIb,WAAO;AAAA;;;AClCT,MAAA;AAAA;AAAA;AAAA;ACAA,MAAA,QAAkB;;;ACSX,MAAI,WAAU;AACd,eAAY;AACZ,eAAY;AACZ,cAAW;AAElB;AACE,kBAAc,MAAM,UAAU;AAC9B,mBAAe,OAAO,OAAO;AAC7B,eAAU,MAAc,OAAO;AAC/B,aAAQ,YAAY,QAAQ;AAC5B,aAAQ,YAAY;AACpB,YAAO,WAAW,OAAO,MAAM;AAAA;;;AChBlB,eAAc;AAC3B,iBAAY,OAAO,QAAQ,GAAG,SAAS;AACvC,SAAI,YAAY,IAAI,GAAG,SAAQ;AAC/B,SAAI,SAAS,GAAG,GAAG,QAAQ,GAAG;AAC9B,SAAI,SAAS,GAAG,GAAG,OAAO,SAAS;AACnC,SAAI,YAAY,IAAI,GAAG,SAAQ;AAC/B,SAAI,SAAS,GAAG,GAAG,QAAQ,GAAG,SAAS;AACvC,SAAI,SAAS,GAAG,GAAG,QAAQ,GAAG,SAAS;AACvC,SAAI,YAAY,IAAI,GAAG,SAAQ;AAC/B,SAAI,SAAS,GAAG,GAAG,OAAO,SAAS;AACnC,SAAI,SAAS,GAAG,GAAG,QAAQ,GAAG;AAC9B,SAAI,YAAY,IAAI,GAAG,SAAQ;AAC/B,SAAI,SAAS,GAAG,GAAG,QAAQ,GAAG,SAAS;AACvC,SAAI,SAAS,GAAG,GAAG,QAAQ,GAAG,SAAS;AACvC,SAAI,YAAY,IAAI,GAAG,SAAQ;AAC/B,SAAI,SAAS,GAAG,GAAG,QAAQ,GAAG,SAAS;AACvC,WAAO,KAAI;AAAA;;;ACpBE,yBAAwB;AACrC,gBAAY;AACZ,uBAAmB;AACjB,UAAI,SAAS;AACX,iBAAS,KAAK,KAAK;AACnB;AAAA;AAEF,oBAAc,KAAK,MAAM;AACzB,kBAAY,MAAM;AAClB,UAAI,CAAC;AAAO,gBAAQ,MAAM,KAAK;AAC/B,UAAI,CAAC;AAAO;AACZ,eAAS,MAAM,QAAQ,KAAK,KAAK;AAAA;AAEnC,QAAI;AACF,eAAS,KAAK,KAAK;AAAA;AAErB,WAAO;AAAA;;;ACbM,sBAAqB;AAClC,mBAAe,OAAO,MAAM,QAAQ,GAAG,MAAM,SAAS;AACtD,mBAAe,QAAQ,KAAK,OAAO,QAAQ;AAC3C,WAAO,UAAU,QAAQ,GAAG;AAC5B,WAAO,UAAU,QAAQ,GAAG;AAC5B,WAAO,UAAU,QAAQ,GAAG;AAC5B,WAAO,UAAU,OAAO,GAAG;AAC3B,WAAO,OAAO;AAAA;;;ACJD,gBAAe;AAC5B,YAAQ,OAAO,OAAO;AAAA,MACpB,MAAM,OAAM;AAAA,MACZ,OAAO,SAAQ;AAAA,MACf,QAAQ;AAAA,OACP;AACH,iBAAa,MAAM;AACnB,QAAI,CAAC;AACH,YAAM,IAAI,MAAM;AAAA;AAGlB,mBAAc,KAAK,MAAM,MAAM;AAC/B,QAAI,CAAC;AACH,iBAAU,KAAY,KAAK,OAAO,KAAK,MAAM,MAAM;AACnD,WAAK,MAAM,MAAM,SAAS;AAAA;AAE5B,cAAU,QAAQ;AAClB,QAAI,CAAC;AACH,cAAQ,cAAc,SAAS,MAAM,MAAM;AAAA;AAE7C,iBAAa,KAAK,KAAK;AACvB,QAAI,MAAM;AACR,gBAAU;AAAA;AAEZ,kBAAa,OAAO,OAAO;AAC3B,YAAQ;AACR,kBAAc,KAAK,KAAK;AACxB,QAAI,MAAM;AACR,iBAAW;AAAA;AAEb,uBAAmB;AACjB,UAAI,SAAS;AACX,aAAK,KAAK,KAAK;AACf;AAAA;AAEF,kBAAY,SAAQ;AACpB,UAAI,CAAC;AAAO,gBAAQ,SAAQ,KAAK;AACjC,UAAI,CAAC;AAAO;AACZ,YAAK,UAAU,OAAO,GAAG;AACzB,WAAK,MAAM,QAAQ;AAAA;AAErB,QAAI,MAAM;AACR,aAAO,WAAW,MAAK,QAAQ,MAAM;AAAA;AAErC,aAAO,MAAK;AAAA;AAAA;;;AC7CD,yBAAwB;AACrC,iBAAa;AACb,kBAAa,KAAK,MAAM,CAAE,QAAQ,SAAQ;AAC1C,kBAAc;AACd,mBAAe,OAAO,MAAK,SAAS,IAAI;AACxC,iBAAY,UAAU,OAAO,QAAQ,SAClC,WAAW;AACd,cAAU,KAAK,KAAK,QAAQ,IAAK,OAAK,QAAQ,KAAK;AACnD,SAAI,UAAU,OAAM,GAAG;AACvB,WAAO,KAAI;AAAA;AAGb;AACE,QAAI,CAAC;AAAS,gBAAU;AACxB,qBAAgB,MAAK,SAAS;AAC9B,iBAAY,OAAO,QAAQ,GAAG;AAC9B,SAAI,YAAY,IAAI,GAAG,SAAQ;AAC/B,SAAI,SAAS,GAAG,GAAG,QAAQ,GAAG;AAC9B,SAAI,YAAY,IAAI,GAAG,SAAQ;AAC/B,SAAI,SAAS,GAAG,GAAG,QAAQ,GAAG,SAAS;AACvC,SAAI,YAAY,IAAI,GAAG,SAAQ;AAC/B,SAAI,SAAS,GAAG,SAAS,GAAG,QAAQ,GAAG;AACvC,SAAI,UAAU,MAAK,SAAS,OAAO,GAAG;AACtC,SAAI,UAAU,MAAK,SAAS,KAAK,QAAQ,GAAG;AAC5C,WAAO,KAAI;AAAA;;;ACpBE,mBAAkB;AAC/B,iBAAa;AACb,iBAAa;AACb,iBAAa;AACb,iBAAa;AACb,iBAAa,OAAM;AAEnB,uBAAmB,QAAQ,OAAO;AAClC,mBAAgB,MAAK,KAAK,aAAa,KAAK,KAAK,aAAa,IAAI,OAAO;AACzE,iBAAY,IAAI,QAAQ,GAAG,SAAS;AACpC,eAAU;AAEV,qBAAgB,OAAO,OAAO,SAAS;AACvC,WAAO;AAEP,qBAAgB,IAAW,MAAM,SAAQ;AACzC,sBAAkB,IAAW,MAAM,SAAQ;AAC3C;AACA,UAAK;AAEL,WAAO,CAAE,QAAQ,SAAQ,QAAQ,OAAO,aAAM;AAE9C;AACE,mBAAa,QAAQ;AACrB,UAAI,CAAC;AAAM,eAAO;AAClB,UAAI,SAAS;AACX,aAAK,KAAK,KAAK;AAAA;AAEf,sBAAc,SAAQ,SAAS,SAAQ,KAAK;AAC5C,YAAI,CAAC;AACH,kBAAQ,KAAK,wBAAwB,OAAO;AAAA;AAE5C,yBAAe,UAAU,SAAS,UAAU,KAAK;AACjD,mBAAQ,UAAU,QAAQ,IAAI,GAAG,IAAI;AACrC,mBAAQ,UAAU,QAAQ,GAAG,IAAI;AACjC,mBAAQ,UAAU,QAAQ,IAAI,GAAG;AACjC,mBAAQ,UAAU,OAAO,GAAG;AAC5B,eAAK,MAAM,QAAQ,KAAK,KAAK;AAAA;AAAA;AAGjC,UAAI,EAAE,MAAM,MAAM,KAAK;AACrB,YAAI;AACJ,aAAK,KAAK,KAAK,aAAa,KAAK,KAAK;AACtC,cAAM;AACN;AAAA;AAEF,aAAO;AAAA;AAGT;AACE;AACA,UAAI;AACJ,UAAI;AACJ,UAAI,OAAO,OAAO;AAClB,YAAM;AACN,YAAM;AACN,gBAAU;AACV,cAAQ,MAAM,SAAS,KAAK,MAAM;AAAA;AAGpC;AACE,eAAQ,YAAY,IAAI,GAAG,SAAQ;AACnC,eAAQ,SAAS,MAAM,OAAO,OAAO,GAAG,QAAQ,OAAO,GAAG,SAAS,OAAO,IAAI;AAAA;AAGhF,kCAA8B;AAC5B,aAAM,YAAQ,cAAI,QAAO,SAAQ;AACjC,eAAQ;AACR,UAAI,SAAS;AACX,aAAI,SAAQ,OAAO,QAAQ,KAAI,QAAQ;AAAA;AAEzC,eAAQ,UAAU,GAAG,GAAG,SAAQ,OAAO,OAAO,SAAQ,OAAO;AAC7D,eAAQ,UAAU,MAAK,GAAG;AAC1B,eAAQ,UAAU,MAAK,IAAG;AAAA;AAAA;;;AC3E9B,MAAM,QAAQ,SAAS,cAAc;AACrC,eAAe,SAAS,cAAc;AACtC,WAAS,KAAK,YAAY;AAE1B,iBAAc;AACd,gBAAc;AACd,kBAAgB;AAChB,kBAAgB;AAChB,cAAY;AACZ,eAAa;AACb,cAAY;AACZ,aAAW;AAEJ;AACL,QAAI;AAAW,aAAO;AACtB,QAAI;AACF,gBAAU,SAAQ;AAAA;AAElB,kBAAY,SAAQ,OAAO,WAAW;AACtC,gBAAU,SAAQ,OAAO,QAAQ;AACjC,gBAAU,SAAQ,OAAO,SAAS;AAClC,gBAAU;AACV,gBAAU;AACV,gBAAU,MAAM,OAAO,IAAI;AAC3B,UAAI,UAAU,MAAM,GAAG,IAAI;AAC3B,eAAS,KAAK,MAAM,KAAK,IAAI,IAAI,IAAI,KAAK,MAAM;AAChD,UAAI,UAAU,OAAO,GAAG,IAAI;AAAA;AAAA;AAIzB;AACL,qBAAiB,MAAM;AACvB,WAAQ,OAAO,QAAQ,SAAU;AACjC,WAAO,YAAY,mBAAO;AAAA,MACxB,MAAM;AAAA,QACJ,OAAO,QAAQ;AAAA,QACf,QAAQ,SAAS;AAAA,QACjB,WAAW,SAAS;AAAA;AAAA;AAIxB,kBAAc,MAAM;AACpB,0BAAsB,MAAM,OAAO,MAAM;AACzC,oBAAgB,MAAM,OAAO;AAC7B,qBAAiB,KAAK,IAAI,KAAK,SAAS,QAAQ;AAChD,eAAU,QAAQ,QAAQ,MAAM,SAAS;AACzC,aAAQ,OAAO,YAAY;AAC3B,gBAAY;AAGZ,YAAQ,YAAQ,QAAQ,KAAK,OAAM,OAAO,QAAQ,SAAQ,MAAM,SAAQ;AAGxE,WAAO,QAAQ,KAAK,OAAO,QAAQ,SAAQ;AAE3C,eAAW;AACT,cAAO,UAAU;AACjB,cAAO,WAAW;AAElB;AACE,iBAAS;AACT,eAAO,sBAAsB;AAAA;AAG/B,uBAAiB,SAAQ;AACzB,YAAM,YAAY;AAClB,kBAAY;AACZ,eAAS,UAAU,IAAI;AACvB,eAAS,iBAAiB,gBAAgB;AACxC,iBAAS,oBAAoB,gBAAgB;AAC7C,iBAAS,UAAU,OAAO;AAC1B,oBAAY;AACZ;AAAA;AAGF,aAAO,iBAAiB,UAAU,QAAK,SAAS;AAChD,aAAO,iBAAiB,SAAS,QAAK,SAAS;AAAA,OAC9C;AAAA;AAGL,sBAAsB;AACpB,QAAI,MAAM,UAAU;AAAO;AAC3B,YAAQ,MAAM;AACd,0BAAsB,MAAM,OAAO,MAAM;AACzC,QAAI,cAAc;AAChB,kBAAY;AAEZ,uBAAiB,SAAQ;AACzB,kBAAY;AACZ,eAAS,UAAU,IAAI;AACvB,eAAS,iBAAiB,gBAAgB;AACxC,iBAAS,oBAAoB,gBAAgB;AAC7C,iBAAS,UAAU,OAAO;AAE1B,wBAAgB,MAAM,OAAO;AAC7B,iBAAQ,OAAO,QAAQ,MAAM,QAAQ;AACrC,iBAAQ,KAAK;AAEb,iBAAS,UAAU,IAAI;AACvB,iBAAS,iBAAiB,gBAAgB;AACxC,mBAAS,oBAAoB,gBAAgB;AAC7C,mBAAS,UAAU,OAAO;AAC1B,sBAAY;AACZ,oBAAU;AAAA;AAAA;AAAA;AAId,eAAQ,KAAK;AACb,gBAAU;AAAA;AAAA;;;AC/Gd,MAAM,QAAQ;AAAA,IACZ,CAAE,MAAM,WAAW,MAAM,CAAC,GAAG,IAAI,SAAS;AAAA,IAC1C,CAAE,MAAM,OAAO,MAAM,CAAC,GAAG,IAAI,SAAS;AAAA;AAGxC,OAAQ,aAAM,UAAW,MAAM;AAAA,IAC7B,OAAO;AAAA,MACL,MAAM;AAAA,MACN,QAAQ;AAAA,MACR,OAAO;AAAA,QACL,OAAO;AAAA,QACP,SAAS;AAAA,QACT,MAAM;AAAA,QACN,QAAQ;AAAA,UACN,CAAE,MAAM,QAAQ,MAAM;AAAA,UACtB,CAAE,MAAM,OAAO,MAAM;AAAA,UACrB,CAAE,MAAM,OAAO,MAAM;AAAA;AAAA,QAEvB,QAAQ;AAAA,UACN,CAAC,GAAG;AAAA,UACJ,CAAC,GAAG;AAAA,UACJ,CAAC,GAAG;AAAA,UACJ,CAAC,GAAG;AAAA,UACJ,CAAC,GAAG;AAAA,UACJ,CAAC,GAAG;AAAA;AAAA;AAAA,MAGR,MAAM;AAAA,QACJ,QAAQ;AAAA,QACR,OAAO;AAAA,QACP,QAAQ;AAAA,QACR;AAAA,QACA,SAAS,MAAM,OAAO,UAAQ,KAAK,YAAY;AAAA,QAC/C,OAAO;AAAA;AAAA,MAET,UAAU;AAAA,QACR,QAAQ;AAAA,UACN,OAAO;AAAA,UACP,QAAQ;AAAA;AAAA,QAEV,OAAO,OAAO;AAAA,QACd,QAAQ,OAAO;AAAA,QACf,OAAO;AAAA;AAAA;AAAA,IAGX,SAAS;AAAA,MACP,QAAQ,WACL,EAAE,MAAM,MAAM,OAAO;AAAA,MAExB,WAAW,wBACR,EAAE,QAAQ;AAAA,MAEb,QAAQ,EAAG;AACT,0BAAkB,KAAK,MAAM,OAAO,aAAa,SAAS,OAAO;AACjE,0BAAkB,KAAK,MAAM,OAAO,cAAc,SAAS,OAAO;AAClE,uBAAe,KAAK,IAAI,GAAG;AAC3B,uBAAe,KAAK,IAAI,GAAG;AAC3B,sBAAc,KAAK,IAAI,QAAQ;AAC/B,sBAAc,KAAK,KAAK,OAAO,aAAa;AAC5C,uBAAe,KAAK,KAAK,OAAO,cAAc;AAC9C,eAAO,CAAE,UAAU,IAAK,UAAU,OAAO,QAAQ;AAAA;AAAA,MAOnD,SAAS,EAAG;AACV,YAAI,CAAC,MAAM,OAAO,MAAM,QAAQ;AAAI,iBAAO,CAAE;AAE7C,eAAO,CAAE,OAAO,IAAK,OAAO,SAAS,MAAM,OAAO,MAAM,QAAQ;AAAA;AAAA;AAAA;AAKtE,QAAK;AACH,UAAM,KAAK;AACX,aAAS;AACT,SAAS,OAAO,UAAU;AAAA;",
  "names": []
}
